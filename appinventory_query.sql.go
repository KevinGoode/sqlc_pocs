// Code generated by sqlc. DO NOT EDIT.
// source: appinventory_query.sql

package main

import (
	"context"
	"database/sql"
)

const createAsset = `-- name: CreateAsset :exec
INSERT INTO assets (id,name,last_updated) VALUES ($1, $2, $3)
`

type CreateAssetParams struct {
	ID          string         `json:"id"`
	Name        sql.NullString `json:"name"`
	LastUpdated sql.NullInt64  `json:"last_updated"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) error {
	_, err := q.exec(ctx, q.createAssetStmt, createAsset, arg.ID, arg.Name, arg.LastUpdated)
	return err
}

const createAssetHost = `-- name: CreateAssetHost :exec
INSERT INTO asset_hosts (id,host_id, asset_id) VALUES ($1, $2, $3)
`

type CreateAssetHostParams struct {
	ID      string         `json:"id"`
	HostID  sql.NullString `json:"host_id"`
	AssetID sql.NullString `json:"asset_id"`
}

func (q *Queries) CreateAssetHost(ctx context.Context, arg CreateAssetHostParams) error {
	_, err := q.exec(ctx, q.createAssetHostStmt, createAssetHost, arg.ID, arg.HostID, arg.AssetID)
	return err
}

const createHost = `-- name: CreateHost :exec
INSERT INTO hosts (id,name,atlas_id,last_updated) VALUES ($1, $2, $3, $4)
`

type CreateHostParams struct {
	ID          string         `json:"id"`
	Name        sql.NullString `json:"name"`
	AtlasID     sql.NullString `json:"atlas_id"`
	LastUpdated sql.NullInt64  `json:"last_updated"`
}

func (q *Queries) CreateHost(ctx context.Context, arg CreateHostParams) error {
	_, err := q.exec(ctx, q.createHostStmt, createHost,
		arg.ID,
		arg.Name,
		arg.AtlasID,
		arg.LastUpdated,
	)
	return err
}

const deleteAsset = `-- name: DeleteAsset :exec
DELETE FROM assets WHERE id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteAssetStmt, deleteAsset, id)
	return err
}

const deleteAssetHost = `-- name: DeleteAssetHost :exec
DELETE FROM asset_hosts WHERE id = $1
`

func (q *Queries) DeleteAssetHost(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteAssetHostStmt, deleteAssetHost, id)
	return err
}

const deleteHost = `-- name: DeleteHost :exec
DELETE FROM hosts WHERE id = $1
`

func (q *Queries) DeleteHost(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteHostStmt, deleteHost, id)
	return err
}

const getAllAssetHosts = `-- name: GetAllAssetHosts :many
SELECT id, host_id, asset_id FROM asset_hosts
`

func (q *Queries) GetAllAssetHosts(ctx context.Context) ([]AssetHost, error) {
	rows, err := q.query(ctx, q.getAllAssetHostsStmt, getAllAssetHosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetHost
	for rows.Next() {
		var i AssetHost
		if err := rows.Scan(&i.ID, &i.HostID, &i.AssetID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAssets = `-- name: GetAllAssets :many
SELECT id, name, last_updated FROM assets
`

func (q *Queries) GetAllAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.query(ctx, q.getAllAssetsStmt, getAllAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(&i.ID, &i.Name, &i.LastUpdated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllHosts = `-- name: GetAllHosts :many
SELECT id, name, atlas_id, address, last_updated FROM hosts
`

func (q *Queries) GetAllHosts(ctx context.Context) ([]Host, error) {
	rows, err := q.query(ctx, q.getAllHostsStmt, getAllHosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Host
	for rows.Next() {
		var i Host
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AtlasID,
			&i.Address,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAsset = `-- name: GetAsset :one
SELECT id, name, last_updated FROM assets WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAsset(ctx context.Context, id string) (Asset, error) {
	row := q.queryRow(ctx, q.getAssetStmt, getAsset, id)
	var i Asset
	err := row.Scan(&i.ID, &i.Name, &i.LastUpdated)
	return i, err
}

const getHost = `-- name: GetHost :one
SELECT id, name, atlas_id, address, last_updated FROM hosts WHERE id = $1 LIMIT 1
`

func (q *Queries) GetHost(ctx context.Context, id string) (Host, error) {
	row := q.queryRow(ctx, q.getHostStmt, getHost, id)
	var i Host
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AtlasID,
		&i.Address,
		&i.LastUpdated,
	)
	return i, err
}

const getHostsForAsset = `-- name: GetHostsForAsset :many
SELECT name, address FROM hosts INNER JOIN asset_hosts ON hosts.id = asset_hosts.host_id WHERE asset_hosts.asset_id=$1
`

type GetHostsForAssetRow struct {
	Name    sql.NullString `json:"name"`
	Address sql.NullString `json:"address"`
}

func (q *Queries) GetHostsForAsset(ctx context.Context, assetID sql.NullString) ([]GetHostsForAssetRow, error) {
	rows, err := q.query(ctx, q.getHostsForAssetStmt, getHostsForAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHostsForAssetRow
	for rows.Next() {
		var i GetHostsForAssetRow
		if err := rows.Scan(&i.Name, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHostAddress = `-- name: UpdateHostAddress :exec
UPDATE hosts SET address = $1 WHERE id = $2
`

type UpdateHostAddressParams struct {
	Address sql.NullString `json:"address"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateHostAddress(ctx context.Context, arg UpdateHostAddressParams) error {
	_, err := q.exec(ctx, q.updateHostAddressStmt, updateHostAddress, arg.Address, arg.ID)
	return err
}
